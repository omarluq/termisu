<footer class="docs-footer">
  <div class="docs-footer-inner">
    <p>
      <span class="iconify" data-icon="pixelarticons:terminal"></span>
      Built with <a href="https://hwaro.hahwul.com/" target="_blank" rel="noopener">Hwaro</a>.
    </p>
    <p class="footer-copyright">
      <span class="iconify" data-icon="pixelarticons:badge-captions"></span>
      All rights reserved Omar Alani
    </p>
  </div>
</footer>
<div class="search-overlay" data-search-overlay hidden></div>
<dialog id="docs-search-panel" class="search-panel" data-search-panel aria-label="Search docs" hidden>
  <div class="search-panel-head">
    <span class="iconify" data-icon="pixelarticons:search"></span>
    <input
      type="search"
      class="search-input"
      data-search-input
      placeholder="Search docs..."
      autocomplete="off"
      spellcheck="false"
    >
    <button type="button" class="search-close" data-search-close aria-label="Close search">
      <span class="iconify" data-icon="pixelarticons:close"></span>
    </button>
  </div>
  <p class="search-hint">Search titles and content. Press <kbd>/</kbd> to open and <kbd>Esc</kbd> to close.</p>
  <ul class="search-results" data-search-results aria-live="polite"></ul>
</dialog>
<script src="https://code.iconify.design/3/3.1.1/iconify.min.js"></script>
<script type="module">
  import Fuse from 'https://esm.sh/fuse.js@7.1.0?bundle'
  import { codeToHtml } from 'https://esm.sh/shiki@3.0.0'

  function logNonFatalError(context, error) {
    if (globalThis.console && typeof globalThis.console.debug === 'function') {
      globalThis.console.debug(`[docs] ${context}`, error)
    }
  }

  function scanIconify(target = undefined) {
    if (globalThis.Iconify && typeof globalThis.Iconify.scan === 'function') {
      globalThis.Iconify.scan(target)
    }
  }

  function normalizePath(path) {
    if (!path) return '/'
    let value = path
    if (!value.startsWith('/')) value = `/${value}`
    value = value.replaceAll(/\/{2,}/g, '/')
    if (value.length > 1 && value.endsWith('/')) value = value.slice(0, -1)
    return `${value}/`.replaceAll('//', '/')
  }

  function pathFromHref(href) {
    try {
      const url = new URL(href, globalThis.location.origin)
      if (url.origin !== globalThis.location.origin) return null
      return normalizePath(url.pathname)
    } catch (error) {
      logNonFatalError('pathFromHref', error)
      return null
    }
  }

  const themeStorageKey = 'termisu-docs-theme'
  const themeMeta = {
    terminal: { label: 'Neon Night', icon: 'pixelarticons:moon-star' },
    logo: { label: 'Termisu Wood', icon: 'pixelarticons:sun' },
  }

  function sanitizeTheme(theme) {
    return theme === 'logo' ? 'logo' : 'terminal'
  }

  function getCurrentTheme() {
    return sanitizeTheme(document.documentElement.dataset.theme || 'terminal')
  }

  function hydrateTheme() {
    let theme = getCurrentTheme()
    try {
      theme = sanitizeTheme(localStorage.getItem(themeStorageKey) || theme)
    } catch (error) {
      logNonFatalError('hydrateTheme', error)
      theme = sanitizeTheme(theme)
    }
    document.documentElement.dataset.theme = theme
    return theme
  }

  function syncFavicon(activeTheme = getCurrentTheme()) {
    const file = activeTheme === 'logo' ? 'favicon-wood.svg' : 'favicon.svg'
    for (const rel of ['icon', 'shortcut icon']) {
      const link = document.querySelector(`link[rel="${rel}"]`)
      if (!link) continue
      try {
        link.href = new URL(`/${file}`, globalThis.location.origin).href
      } catch (error) {
        logNonFatalError('syncFavicon', error)
        link.setAttribute('href', `/${file}`)
      }
    }
  }

  function updateThemeToggle(root = document, activeTheme = getCurrentTheme()) {
    const toggle = root.querySelector('[data-theme-toggle]')
    if (!toggle) return

    const nextTheme = activeTheme === 'terminal' ? 'logo' : 'terminal'
    const activeMeta = themeMeta[activeTheme]
    const nextMeta = themeMeta[nextTheme]
    toggle.dataset.nextTheme = nextTheme
    toggle.title = `Theme: ${activeMeta.label} (switch to ${nextMeta.label})`
    toggle.setAttribute('aria-label', `Switch to ${nextMeta.label} theme`)

    const icon = toggle.querySelector('[data-theme-icon]')
    if (icon) icon.dataset.icon = activeMeta.icon
    scanIconify(toggle)
  }

  function setTheme(theme, root = document) {
    const safeTheme = sanitizeTheme(theme)
    document.documentElement.dataset.theme = safeTheme
    try {
      localStorage.setItem(themeStorageKey, safeTheme)
    } catch (error) {
      logNonFatalError('setTheme', error)
    }
    syncFavicon(safeTheme)
    updateThemeToggle(root, safeTheme)
  }

  function initThemeToggle(root = document) {
    const toggle = root.querySelector('[data-theme-toggle]')
    if (!toggle) return
    if (toggle.dataset.bound === '1') {
      updateThemeToggle(root)
      return
    }

    toggle.dataset.bound = '1'
    updateThemeToggle(root)
    toggle.addEventListener('click', () => {
      setTheme(toggle.dataset.nextTheme || 'terminal', root)
    })
  }

  function markActiveLinks(root = document) {
    const current = normalizePath(globalThis.location.pathname)
    const sidebarLinks = Array.from(root.querySelectorAll('.docs-sidebar .sidebar-links a[href]'))
    let activeSidebar = null

    for (const link of sidebarLinks) {
      link.classList.remove('active')
      if (pathFromHref(link.getAttribute('href')) === current) {
        activeSidebar = link
      }
    }

    if (activeSidebar) activeSidebar.classList.add('active')
  }

  function isMobileSidebar() {
    return globalThis.matchMedia('(max-width: 61.25rem)').matches
  }

  function setSidebarOpen(open, root = document) {
    const body = root.body || document.body
    if (!body) return

    body.classList.toggle('docs-sidebar-open', open)

    const toggle = root.querySelector('[data-sidebar-toggle]')
    if (!toggle) return

    toggle.setAttribute('aria-expanded', open ? 'true' : 'false')
    toggle.setAttribute('aria-label', open ? 'Hide docs navigation' : 'Show docs navigation')

    const icon = toggle.querySelector('[data-sidebar-toggle-icon]')
    if (icon) icon.dataset.icon = open ? 'pixelarticons:close' : 'pixelarticons:menu'
  }

  function initSidebarToggle(root = document) {
    const toggle = root.querySelector('[data-sidebar-toggle]')
    const sidebar = root.querySelector('[data-sidebar]')
    if (!toggle || !sidebar) return

    if (toggle.dataset.bound !== '1') {
      toggle.dataset.bound = '1'

      toggle.addEventListener('click', () => {
        const isOpen = (root.body || document.body).classList.contains('docs-sidebar-open')
        setSidebarOpen(!isOpen, root)
        scanIconify(toggle)
      })

      sidebar.addEventListener('click', (event) => {
        const target = event.target
        if (!(target instanceof Element)) return
        const link = target.closest('a[href]')
        if (!link || !isMobileSidebar()) return
        setSidebarOpen(false, root)
      })

      globalThis.addEventListener('resize', () => {
        if (!isMobileSidebar()) setSidebarOpen(false, root)
      })
    }

    setSidebarOpen(false, root)
  }

  const searchState = {
    items: [],
    fuse: null,
    loadPromise: null,
  }

  function isTypingContext(target) {
    if (!(target instanceof HTMLElement)) return false
    if (target.isContentEditable) return true
    const tag = target.tagName
    return tag === 'INPUT' || tag === 'TEXTAREA' || tag === 'SELECT'
  }

  function getSearchElements(root = document) {
    return {
      body: root.body || document.body,
      toggle: root.querySelector('[data-search-toggle]'),
      panel: root.querySelector('[data-search-panel]'),
      overlay: root.querySelector('[data-search-overlay]'),
      input: root.querySelector('[data-search-input]'),
      close: root.querySelector('[data-search-close]'),
      results: root.querySelector('[data-search-results]'),
    }
  }

  function renderSearchStatus(message, root = document) {
    const { results } = getSearchElements(root)
    if (!results) return
    results.replaceChildren()
    const item = document.createElement('li')
    item.className = 'search-empty'
    item.textContent = message
    results.append(item)
  }

  async function ensureSearchIndexLoaded() {
    if (searchState.fuse) return searchState.fuse
    if (searchState.loadPromise) return searchState.loadPromise

    const url = new URL('/search.json', globalThis.location.origin).href
    searchState.loadPromise = fetch(url, { cache: 'force-cache' })
      .then((response) => {
        if (!response.ok) throw new Error(`Failed search index request: ${response.status}`)
        return response.json()
      })
      .then((payload) => {
        const items = Array.isArray(payload)
          ? payload.filter((item) => item && typeof item.url === 'string' && typeof item.title === 'string')
          : []

        searchState.items = items
        searchState.fuse = new Fuse(items, {
          includeScore: true,
          threshold: 0.34,
          ignoreLocation: true,
          minMatchCharLength: 2,
          keys: [
            { name: 'title', weight: 0.58 },
            { name: 'content', weight: 0.37 },
            { name: 'url', weight: 0.05 },
          ],
        })
        return searchState.fuse
      })
      .catch((error) => {
        searchState.loadPromise = null
        throw error
      })

    return searchState.loadPromise
  }

  function buildSearchSnippet(item, query) {
    const raw = typeof item.content === 'string' ? item.content : ''
    const content = raw.replaceAll(/\s+/g, ' ').trim()
    const fallback = item.url || '/'
    if (!content) return fallback

    const maxLength = 120
    if (!query) {
      return content.length > maxLength ? `${content.slice(0, maxLength)}...` : content
    }

    const needle = query.toLowerCase()
    const index = content.toLowerCase().indexOf(needle)
    if (index < 0) {
      return content.length > maxLength ? `${content.slice(0, maxLength)}...` : content
    }

    const start = Math.max(0, index - 34)
    const end = Math.min(content.length, index + query.length + 70)
    const prefix = start > 0 ? '... ' : ''
    const suffix = end < content.length ? ' ...' : ''
    return `${prefix}${content.slice(start, end)}${suffix}`
  }

  function renderSearchResults(query, root = document) {
    const { results } = getSearchElements(root)
    if (!results) return

    const normalizedQuery = query.trim()
    const matches = normalizedQuery
      ? searchState.fuse.search(normalizedQuery, { limit: 12 }).map((entry) => entry.item)
      : searchState.items.slice(0, 10)

    results.replaceChildren()
    if (!matches.length) {
      const empty = document.createElement('li')
      empty.className = 'search-empty'
      empty.textContent = normalizedQuery ? `No matches for "${normalizedQuery}".` : 'Start typing to search docs.'
      results.append(empty)
      return
    }

    const fragment = document.createDocumentFragment()
    for (const item of matches) {
      const entry = document.createElement('li')
      entry.className = 'search-result-item'

      const link = document.createElement('a')
      link.href = item.url

      const title = document.createElement('span')
      title.className = 'search-result-title'
      title.textContent = item.title

      const path = document.createElement('span')
      path.className = 'search-result-url'
      path.textContent = item.url

      const snippet = document.createElement('span')
      snippet.className = 'search-result-snippet'
      snippet.textContent = buildSearchSnippet(item, normalizedQuery)

      link.append(title, path, snippet)
      entry.append(link)
      fragment.append(entry)
    }

    results.append(fragment)
  }

  function setDialogOpen(panel, open) {
    if (panel instanceof HTMLDialogElement) {
      if (open) {
        panel.hidden = false
        if (!panel.open) panel.showModal()
      } else {
        if (panel.open) panel.close()
        panel.hidden = true
      }
      return
    }

    panel.hidden = !open
  }

  function setSearchOpen(open, root = document) {
    const { body, toggle, panel, overlay, input } = getSearchElements(root)
    if (!body || !panel || !overlay) return

    if (open) setSidebarOpen(false, root)

    body.classList.toggle('search-open', open)
    setDialogOpen(panel, open)
    overlay.hidden = !open

    if (toggle) {
      toggle.setAttribute('aria-expanded', open ? 'true' : 'false')
      toggle.setAttribute('aria-label', open ? 'Close search' : 'Open search')
    }

    if (!open) return

    ensureSearchIndexLoaded()
      .then(() => {
        const query = input && typeof input.value === 'string' ? input.value : ''
        renderSearchResults(query, root)
      })
      .catch((error) => {
        logNonFatalError('setSearchOpen', error)
        renderSearchStatus('Search index is unavailable.', root)
      })

    if (input) {
      globalThis.requestAnimationFrame(() => {
        input.focus()
        input.select()
      })
    }
  }

  function initSearch(root = document) {
    const { body, toggle, panel, overlay, input, close, results } = getSearchElements(root)
    if (!toggle || !panel || !overlay || !input || !close || !results || !body) return
    if (toggle.dataset.bound === '1') return

    toggle.dataset.bound = '1'

    toggle.addEventListener('click', () => {
      const isOpen = body.classList.contains('search-open')
      setSearchOpen(!isOpen, root)
      scanIconify(toggle)
    })

    close.addEventListener('click', () => setSearchOpen(false, root))
    overlay.addEventListener('click', () => setSearchOpen(false, root))

    panel.addEventListener('click', (event) => {
      const target = event.target
      if (!(target instanceof Element)) return
      const link = target.closest('a[href]')
      if (!link) return
      setSearchOpen(false, root)
    })

    panel.addEventListener('close', () => {
      setSearchOpen(false, root)
    })

    let pendingInput = 0
    input.addEventListener('input', () => {
      globalThis.clearTimeout(pendingInput)
      pendingInput = globalThis.setTimeout(async () => {
        try {
          await ensureSearchIndexLoaded()
          renderSearchResults(input.value || '', root)
        } catch (error) {
          logNonFatalError('search input', error)
          renderSearchStatus('Search index is unavailable.', root)
        }
      }, 60)
    })

    document.addEventListener('keydown', (event) => {
      if (event.defaultPrevented) return

      const isOpen = body.classList.contains('search-open')
      if (event.key === 'Escape' && isOpen) {
        event.preventDefault()
        setSearchOpen(false, root)
        return
      }

      if (isTypingContext(event.target)) return

      if (event.key === '/' && !event.ctrlKey && !event.metaKey && !event.altKey) {
        event.preventDefault()
        setSearchOpen(true, root)
        return
      }

      if ((event.key === 'k' || event.key === 'K') && (event.ctrlKey || event.metaKey)) {
        event.preventDefault()
        setSearchOpen(true, root)
      }
    })

    setSearchOpen(false, root)

    if ('requestIdleCallback' in globalThis) {
      globalThis.requestIdleCallback(() => ensureSearchIndexLoaded().catch((error) => logNonFatalError('search warmup', error)))
    } else {
      globalThis.setTimeout(() => ensureSearchIndexLoaded().catch((error) => logNonFatalError('search warmup', error)), 400)
    }
  }

  function createSpacer() {
    const spacer = document.createElement('span')
    spacer.className = 'nav-spacer'
    return spacer
  }

  function createPrevLink(source) {
    const anchor = document.createElement('a')
    anchor.className = 'prev-link'
    anchor.href = source.getAttribute('href') || '#'

    const icon = document.createElement('span')
    icon.className = 'iconify'
    icon.dataset.icon = 'pixelarticons:arrow-left'
    anchor.append(icon, document.createTextNode(source.textContent?.trim() || 'Previous'))
    return anchor
  }

  function createNextLink(source) {
    const anchor = document.createElement('a')
    anchor.className = 'next-link'
    anchor.href = source.getAttribute('href') || '#'

    const label = document.createTextNode(source.textContent?.trim() || 'Next')
    const icon = document.createElement('span')
    icon.className = 'iconify'
    icon.dataset.icon = 'pixelarticons:arrow-right'
    anchor.append(label, icon)
    return anchor
  }

  function collectOrderedSidebarLinks(root = document) {
    const sidebarLinks = Array.from(root.querySelectorAll('.docs-sidebar .sidebar-links a[href]'))
    const ordered = []
    const seen = new Set()

    for (const link of sidebarLinks) {
      const path = pathFromHref(link.getAttribute('href'))
      if (!path || seen.has(path)) continue
      seen.add(path)
      ordered.push({ path, link })
    }
    return ordered
  }

  function findPrevNextLink(current, ordered) {
    if (current === '/') {
      return {
        prev: null,
        next: ordered.find((item) => item.path !== current)?.link || null,
      }
    }

    const index = ordered.findIndex((item) => item.path === current)
    if (index < 0) return { prev: null, next: null }

    return {
      prev: index > 0 ? ordered[index - 1].link : null,
      next: index < ordered.length - 1 ? ordered[index + 1].link : null,
    }
  }

  function renderPrevNext(root = document) {
    const nav = root.querySelector('.doc-prev-next')
    if (!nav) return

    const current = normalizePath(globalThis.location.pathname)
    const ordered = collectOrderedSidebarLinks(root)
    const { prev, next } = findPrevNextLink(current, ordered)

    nav.replaceChildren(
      prev ? createPrevLink(prev) : createSpacer(),
      next ? createNextLink(next) : createSpacer(),
    )
  }

  function slugifyHeading(value) {
    return value
      .toLowerCase()
      .replaceAll(/[^a-z0-9\s-]/g, '')
      .trim()
      .replaceAll(/\s+/g, '-')
      .replaceAll(/-+/g, '-')
  }

  function tocClassForHeading(tagName) {
    if (tagName === 'H1') return 'toc-l1'
    if (tagName === 'H3') return 'toc-l3'
    return 'toc-l2'
  }

  function renderPageToc(root = document) {
    const toc = root.querySelector('.docs-toc .toc-links')
    const content = root.querySelector('.docs-main')
    if (!toc || !content) return

    const headings = Array.from(content.querySelectorAll('h1, h2, h3')).filter(
      (heading) => (heading.textContent || '').trim().length > 0,
    )

    if (!headings.length) {
      toc.replaceChildren()
      const empty = document.createElement('li')
      empty.className = 'toc-empty'
      empty.textContent = 'No sections'
      toc.append(empty)
      return
    }

    const usedIds = new Set(
      Array.from(content.querySelectorAll('[id]'))
        .map((node) => node.id)
        .filter(Boolean),
    )

    const fragment = document.createDocumentFragment()
    for (const heading of headings) {
      if (!heading.id) {
        const base = slugifyHeading(heading.textContent || '') || 'section'
        let candidate = base
        let index = 2
        while (usedIds.has(candidate)) {
          candidate = `${base}-${index}`
          index += 1
        }
        heading.id = candidate
        usedIds.add(candidate)
      }

      const item = document.createElement('li')
      item.className = tocClassForHeading(heading.tagName)

      const link = document.createElement('a')
      link.href = `#${heading.id}`
      link.textContent = (heading.textContent || '').trim()
      item.append(link)
      fragment.append(item)
    }

    toc.replaceChildren(fragment)
  }

  function attachCopyButton(block, source) {
    if (!block || block.dataset.copyAttached === '1') return
    block.dataset.copyAttached = '1'
    block.classList.add('has-copy')

    const button = document.createElement('button')
    button.type = 'button'
    button.className = 'copy-btn'
    button.title = 'Copy code'
    button.setAttribute('aria-label', 'Copy code')
    button.innerHTML = '<span class="iconify" data-icon="pixelarticons:copy"></span>'

    button.addEventListener('click', async () => {
      try {
        await navigator.clipboard.writeText(source)
        button.classList.add('copied')
        button.innerHTML = '<span class="iconify" data-icon="pixelarticons:check"></span>'
        setTimeout(() => {
          button.classList.remove('copied')
          button.innerHTML = '<span class="iconify" data-icon="pixelarticons:copy"></span>'
        }, 900)
      } catch (error) {
        logNonFatalError('copy button', error)
        button.classList.add('copied')
        setTimeout(() => button.classList.remove('copied'), 900)
      }
    })

    block.prepend(button)
  }

  async function enhanceCodeBlocks(root = document) {
    const blocks = Array.from(root.querySelectorAll('pre code'))
    for (const code of blocks) {
      const pre = code.parentElement
      if (!pre || pre.dataset.shikiDone === '1') continue

      const className = Array.from(code.classList).find((name) => name.startsWith('language-'))
      const lang = className && className.startsWith('language-')
        ? className.slice('language-'.length)
        : (className || 'text')
      const source = code.textContent || ''

      try {
        const html = await codeToHtml(source, {
          lang,
          theme: 'vitesse-dark',
        })

        const wrapper = document.createElement('div')
        wrapper.innerHTML = html
        const shiki = wrapper.firstElementChild
        if (!shiki) continue

        shiki.classList.add('code-block')
        shiki.dataset.shikiDone = '1'
        attachCopyButton(shiki, source)
        pre.replaceWith(shiki)
      } catch (error) {
        logNonFatalError('enhanceCodeBlocks', error)
        pre.dataset.shikiDone = '1'
        pre.classList.add('code-block')
        attachCopyButton(pre, source)
      }
    }
  }

  async function enhancePage() {
    const activeTheme = hydrateTheme()
    syncFavicon(activeTheme)
    initThemeToggle(document)
    initSearch(document)
    initSidebarToggle(document)
    markActiveLinks(document)
    renderPageToc(document)
    renderPrevNext(document)
    await enhanceCodeBlocks(document)
    scanIconify()
  }

  await enhancePage()
</script>
{{ highlight_js }}
{{ auto_includes_js }}
</body>
</html>
